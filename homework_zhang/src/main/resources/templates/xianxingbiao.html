<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>线性表</title>
</head>
<body>

<h2>3.1基本概念</h2>
<h2> 线性表（List）：由零个或多个数据元素组成的有限序列。</h2>
<h2> 注意：</h2>
 <h2>1.线性表是一个序列。</h2>
 <h2>2.0个元素构成的线性表是空表。</h2>
 <h2>3.线性表中的第一个元素无前驱，最后一个元素无后继，其他元素有且只有一个前驱和后继。</h2>
 <h2>4.线性表是有长度的，其长度就是元素个数，且线性表的元素个数是有限的，也就是说，线性表的长度是有限的。</h2>
<h2>如果用数学语言来进行定义，可如下：</h2>
<h2> 若将线性表记为（a1,…,ai-1,ai,ai+1,…an）,则表中ai-1领先于ai,ai领先于ai+1,称ai-1是ai的直接前驱元素,ai+1是ai的直接后继元素。 </h2>
<h2>3.2两种不同的线性表</h2>
<h2>我们知道，数据结构分为逻辑结构和物理结构，逻辑结构分为集合结构、线性结构、树形结构和图形结构四大类。</h2>
<h2>物理结构分为顺序存储结构和链式存储结构。我在之前写的《数据结构和算法》中已经介绍过。</h2>
 <h2>线性表是线性结构的一种，那么线性表当然也有物理结构，也就是说，线性表有两种，分别是顺序结构的线性表（叫做顺序表）</h2>
 <h2>和链式结构的线性表（叫做链表）。</h2>
<h2>3.3顺序存储结构的线性表</h2>
 <h2>顺序表是指顺序存储结构的线性表，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</h2>
<h2>顺序表表现在物理内存中，也就是物理上的存储方式，事实上就是在内存中找个初始地址，然后通过占位的形式，把一定的内存空间给占了，</h2>
  <h2>然后把相同数据类型的数据元素依次放在这块空地中。注意，这块物理内存的地址空间是连续的。</h2>
 <h2>3.4顺序表优缺点</h2>
<h2>线性表的顺序存储结构，在存、读取数据时，不管是在哪个位置，时间复杂度都是O(1)。而在插入或者删除时，时间复杂度都是O(n)。</h2>
<h2>这也就是线性表的顺序存储结构比较适合存取数据，不适合经常插入和删除数据的应用。</h2>
<h2>优点：</h2>
 <h2>1.无需为了表示表中元素之间的逻辑关系而增加额外的存储空间（相对于链式存储而言）。</h2>
 <h2>2.可以快速的存取表中任意位置的元素。</h2>
   <h2> 缺点：</h2>
 <h2>1.插入和删除操作需要移动大量的元素。</h2>
   <h2>2.当线性表长度变化较大时，难以确定存储空间的容量。</h2>
   <h2> 3.容易造成存储空间的“碎片”(因为线性表的顺序存储结构申请的内存空间都以连续的，如果因为某些操作（比如删除操作）导致某个部分</h2>
 <h2>出现了一小块的不连续内存空间，因为这一小块内存空间太小不能够再次被利用/分配，那么就造成了内存浪费，也就是“碎片”)</h2>
<h2>3.5链式存储结构的线性表</h2>
 <h2>前面我们讲的线性表的顺序存储结构，它最大的缺点就是插入和删除时需要移动大量元素，这显然就需要耗费时间。那我们能不能针对这个缺陷</h2>
<h2>或者说遗憾提出解决的方法呢？要解决这个问题，我们就得考虑一下导致这个问题的原因！为什么当插入和删除时，就要移动大量的元素？</h2>
 <h2>原因就在于相邻两元素的存储位置也具有邻居关系，它们在内存中的位置是紧挨着的，中间没有间隙，当然就无法快速插入和删除。线性表的</h2>
<h2>链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置。也就是说，链式存储</h2>
 <h2>结构的线性表由一个（可以使零）或者多个结点（Node）组成。每个节点内部又分为数据域和指针域（链）。数据域存储了数据元素的信息。</h2>
   <h2>指针域存储了当前结点指向的直接后继的指针地址。因为每个结点只包含一个指针域，所以叫做单链表。顾名思义，当然还有双链表。</h2>

</body>
</html>